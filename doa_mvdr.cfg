# Real time DOA estimation and MVDR  beamforming
# trial version

srate = 44100      
nchannels_in = 2  
fragsize = 4096    

# Connects openMha to jack audio system:
# Adjust with simulated_scene(_MK)
iolib = MHAIOJack

# Resamples audio from 48 kHz â†’ 16 kHz for DOA/MVDR processing.
# matches my coefficient snippet
mhalib = resampling
mha.srate = 16000 
mha.fragsize = 160
mha.plugin_name = mhachain:doachain

# order of plugins
mha.doachain.algos = [addsndfile gain route:doa_in route:doa_1_2 doasvm_feature_extraction:gcc_1_2 route:doa_1_3 doasvm_feature_extraction:gcc_1_3 route:doa_1_4 doasvm_feature_extraction:gcc_1_4 route:doa_2_3 doasvm_feature_extraction:gcc_2_3 route:doa_2_4 doasvm_feature_extraction:gcc_2_4 route:doa_3_4 doasvm_feature_extraction:gcc_3_4 acConcat_wave:concat doasvm_classification:svm acPooling_wave:pool acsave:doasvm_save  acmon:doasvm_mon route:all altplugs:post wavrec]



mha.doachain.addsndfile.level=60
mha.doachain.addsndfile.levelmode=rms
mha.doachain.addsndfile.channels=[0 1 2 3]
mha.doachain.addsndfile.mode=add
# To use a 4-ch test signal, uncomment the following line
mha.doachain.addsndfile.filename=./input/simulated_scene_mix.wav

# Adds +6 dB gain to each of the 4 channels.
mha.doachain.gain.gains = [6 6 6 6]

# route only four channels to the DOA estimation and save all the channels for future filtering
mha.doachain.doa_in.out = [:0 :1 :2 :3]
mha.doachain.doa_in.ac = [:0 :1 :2 :3]

# configure doasvm_feature_extraction plugins, which compute the GCC matrices
# Repeats 6 times for each pairwise:
mha.doachain.gcc_1_2.fftlen = 160 
mha.doachain.gcc_1_2.nupsample = 4 
mha.doachain.gcc_1_2.max_lag = 20 
mha.doachain.gcc_1_2.vGCC_name = vGCC_ac_1 

mha.doachain.gcc_1_3.fftlen = 160
mha.doachain.gcc_1_3.nupsample = 4
mha.doachain.gcc_1_3.max_lag = 2
mha.doachain.gcc_1_3.vGCC_name = vGCC_ac_2

mha.doachain.gcc_1_4.fftlen = 160
mha.doachain.gcc_1_4.nupsample = 4
mha.doachain.gcc_1_4.max_lag = 20
mha.doachain.gcc_1_4.vGCC_name = vGCC_ac_3

mha.doachain.gcc_2_3.fftlen = 160
mha.doachain.gcc_2_3.nupsample = 4
mha.doachain.gcc_2_3.max_lag = 20
mha.doachain.gcc_2_3.vGCC_name = vGCC_ac_4

mha.doachain.gcc_2_4.fftlen = 160
mha.doachain.gcc_2_4.nupsample = 4
mha.doachain.gcc_2_4.max_lag = 2
mha.doachain.gcc_2_4.vGCC_name = vGCC_ac_5

mha.doachain.gcc_3_4.fftlen = 160
mha.doachain.gcc_3_4.nupsample = 4
mha.doachain.gcc_3_4.max_lag = 20
mha.doachain.gcc_3_4.vGCC_name = vGCC_ac_6




# Routing channels
# configure route plugins for redirecting the corresponding channel pair to the doasvm_feature_extraction plugins
# Which input channels to pass to the next plugin as signal output
# Which input channels to pass as reference (AC = additional channels, or auxiliary channels)

mha.doachain.doa_1_2.out = [:1 :0]  
mha.doachain.doa_1_2.ac = [:2 :3]   

mha.doachain.doa_1_3.out = [doa_1_2:0 :1]                             
mha.doachain.doa_1_3.ac = [:0 doa_1_2:1]                                
mha.doachain.doa_1_4.out = [doa_1_3:1 :1]      
mha.doachain.doa_1_4.ac = [doa_1_3:0 :0]        

mha.doachain.doa_2_3.out = [doa_1_4:1 doa_1_4:0] 
mha.doachain.doa_2_3.ac = [:1 :0]        

mha.doachain.doa_2_4.out = [doa_2_3:1 :1]     
mha.doachain.doa_2_4.ac = [doa_2_3:0 :0]       

mha.doachain.doa_3_4.out = [:0 doa_2_4:1]       
mha.doachain.doa_3_4.ac = [doa_2_4:0 :1]       




# concatenate all pairwise gcc vectors into one big vector
mha.doachain.concat.num_AC = 6
mha.doachain.concat.prefix_names_AC = vGCC_ac
mha.doachain.concat.samples_AC = [161 17 161 161 17 161]
mha.doachain.concat.name_con_AC = vGCC_con_ac


mha.doachain.svm?read:./matrices_4channel_front-rear_bte.cfg

mha.doachain.svm.vGCC_name = vGCC_con_ac


# configure acPooling_wave plugin for pooling the SVM estimations of the recent history
# smooths or averages the recent SVM outputs over time
mha.doachain.pool.p_name = p  
mha.doachain.pool.pool_name = pool
mha.doachain.pool.max_pool_ind_name = pool_max   
mha.doachain.pool.second_max_pool_ind_name = pool_second_max
mha.doachain.pool.numsamples = 73
mha.doachain.pool.pooling_wndlen = 300
mha.doachain.pool.pooling_type = mean 
mha.doachain.pool.upper_threshold = 0.1 
mha.doachain.pool.neighbourhood = 4
mha.doachain.pool.alpha = 0
mha.doachain.pool.prob_bias = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]   # no bias. all classes treated equally.

# Save DOA and GCC
mha.doachain.doasvm_save.name = ./4ch_doasvm.mat
mha.doachain.doasvm_save.fileformat = mat4   
mha.doachain.doasvm_save.reclen = 30 
mha.doachain.doasvm_save.vars = [p p_max pool pool_max ]  



# merge all channels for signal processing/ Combine all four microphone inputs for post-processing.
mha.doachain.all.out = [doa_in:0 doa_in:1 doa_in:2 doa_in:3]

# Post processing_ MVDR beamformer setup
mha.doachain.post.plugs=[route:NoBf overlapadd:Bf]  
mha.doachain.post.select = Bf

mha.doachain.post.NoBf.out=[:0 :1] 

# configure Bf node for steering beamformer filters
mha.doachain.post.Bf.fftlen = 512  
mha.doachain.post.Bf.wnd.len = 320  
mha.doachain.post.Bf.zerownd.type = hanning
mha.doachain.post.Bf.plugin_name = mhachain:bfChain

mha.doachain.post.Bf.bfChain.algos = [route:left_in acSteer:mvdr steerbf:left save_spec:left_out route:right_in steerbf:right route:out]

mha.doachain.post.Bf.bfChain.left_in.out = [:0 :1 :2 :3]
mha.doachain.post.Bf.bfChain.left_in.ac = [:0 :1 :2 :3]

#configure steervec for the left reference microphone
mha.doachain.post.Bf.bfChain.mvdr.steerFile = ./MVDR_iso_norm_bte_16KHz_4ch_lr_FFT512_-180-5-180.txt
mha.doachain.post.Bf.bfChain.mvdr.nsteerchan = 584   
mha.doachain.post.Bf.bfChain.mvdr.acSteerName1 = acSteerLeft
mha.doachain.post.Bf.bfChain.mvdr.acSteerName2 = acSteerRight
mha.doachain.post.Bf.bfChain.mvdr.nrefmic = 2

#configure steerbf for the left reference microphone
mha.doachain.post.Bf.bfChain.left.bf_src = acSteerLeft
mha.doachain.post.Bf.bfChain.left.angle_src = pool_max
#mha.doachain.post.Bf.bfChain.left.angle_ind = 0 

# route the input signal to the beamformer with the right reference microphone
mha.doachain.post.Bf.bfChain.right_in.out = [left_in:0 left_in:1 left_in:2 left_in:3]
mha.doachain.post.Bf.bfChain.right_in.ac = [:0]


#configure steerbf for the right reference microphone
mha.doachain.post.Bf.bfChain.right.bf_src = acSteerRight
mha.doachain.post.Bf.bfChain.right.angle_src = pool_max
#mha.doachain.post.Bf.bfChain.right.angle_ind = 0

# route the filter outputs of the left and right beamformers to the output
mha.doachain.post.Bf.bfChain.out.out = [right_in:0 :0]

mha.doachain.wavrec.record = yes 
mha.doachain.wavrec.prefix = ./Enhanced_

#run the configuration
cmd = start
#cmd=quit

